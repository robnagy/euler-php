<?php

namespace App\Helpers;

class Primes
{
    /**
     * Generates $count amount of primes.
     * Uses sieve to eliminate numbers
     * up to an estimated value.
     *
     * @param integer $count
     * @return array
     */
    public static function generatePrimes(int $count): array
    {
        $primes = [];
        $sieve = [];
        $estimate = self::estimateNumbersContainingXPrimes($count);
        $x = 2;

        while (count($primes) < $count) {
            if (!isset($sieve[$x])) {
                if (isset($primes[$x])) {
                    $num = $primes[$x];
                } else {
                    $num = $x + $x;
                }
                do {
                    $sieve[$num] = 0;
                    $num += $x;
                } while ($num <= $estimate);
                $primes[$x] = $num;
            }
            if ($x === 2) {
                $x++;
            } else {
                $x += 2;
            }

            if ($x > $estimate) {
                $increase = (int) $estimate * 0.05;
                $estimate += $increase;
                echo PHP_EOL . 'increasing estimate by ' . $increase;
                $x = 2;
            }
        }

        return array_keys($primes);
    }

    /**
     * Calculates an estimate of the numbers need to be tested to
     * get $x amount of primes. It uses $x / log($x), which
     * overestimates by 13% for 100, and 8% for 1000000
     *
     * @param integer $x
     * @return integer
     */
    public static function estimateNumbersContainingXPrimes(int $x): int
    {
        $multiplier = 10;
        $guess = $multiplier * $x;
        do {
            $estimate = (int) ($guess / Log($guess));
            if ($estimate < $x) {
                $multiplier += 0.3;
                $guess = $multiplier * $x;
            }

        } while ($estimate - $x < 0);
        $guess = (int) ($guess * 0.8);
        return $guess;
    }

    /**
     * Returns all primes below $limit
     *
     * @param integer $limit
     * @return array
     */
    public static function getPrimesBelow(int $limit): array
    {
        $primes = [];
        $sieve = [];
        for ($x = 2; $x < $limit;) {
            if (!isset($sieve[$x])) {
                $num = $x;
                do {
                    $num += $x;
                    $sieve[$num] = 1;
                } while ($num < $limit);
                $primes[] = $x;
            }

            if ($x === 2) {
                $x++;
            } else {
                $x += 2;
            }

        }
        return $primes;
    }

    /**
     * Retrieves primes up to $limit. Returns primes
     * as keys in an array with true values.
     *
     * @param integer $limit
     * @return array
     */
    public static function generatePrimesKeyedArray(int $limit): array
    {
        $primes = Primes::getPrimesBelow($limit);
        $newPrimes = [];
        foreach ($primes as $prime) {
            $newPrimes[$prime] = true;
        }
        return $newPrimes;
    }

    /**
     * Calculates count of consecutive primes generated by
     * n*n + n*a + b using given a, b, with n=0 and n++
     *
     * @param integer $a
     * @param integer $b
     * @param array $primes
     * @return integer
     */
    public static function quadraticPrimesCount(int $a, int $b, array $primes): int
    {
        $count = 0;
        $n = 0;
        while (true) {
            $x = $n * $n + $n * $a + $b;
            $x = abs($x);
            if ($primes[$x] ?? false) {
                $count++;
                $n++;
            } else {
                break;
            }
        }
        return $count;
    }
}
